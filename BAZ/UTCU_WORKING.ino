// ----------- PIN SETUP -----------

// output pin for controlling antenna 
const int antennaPin1 = 3;
const int antennaPin2 = 4;
const int antennaPin3 = 9;

// For syncing during demo
const int syncPin = 5;

// output pin for encoded data.
const int phasePin = 7;

// output pin for start/stop
const int startPin = 12;

// output pin for to/fro
const int toPin = 13;

// output pin for on/off
const int onPin = 10;

// ----------- CONSTANTS -----------

// const unsigned long MAX_TIME = 615; // If we want to change back to milliseconds.

const unsigned long ERROR_RANGE = 4;

// How much delay (us) after each bit is sent.
const int DELAY = 59;

// The start up time before data at "ms_time zero" starts.
const unsigned int START_UP = 0;

// Number of bytes atenna.
const int ATENNA = 4;

// Number of bytes for opcode.
const int OPCODE = 26;

// Number of bytes for carrier acquision and time sync (Additional number because string as extra '\0').
// const int PLANE_SYNC = 19;

// Number of data words.
const int DATA_WORDS  = 6;
const int BASIC = 46;
const int AUX = 100;

// Scale factor
const unsigned long SCALE_FACTOR = 1;

// Carrier acquisition and time sync
// const char CARRIER_SYNC[PLANE_SYNC] = "000000000000011101";

// This is multiplied to the time to allow for better USSIM waves (default is 1).
const unsigned long SYNC_START = 0;
const unsigned long SYNC_END = 1000;

// Used to see if function ID should be sent.
const char NO_FUNCID[OPCODE] = "0000000000000000000000000";
// ----------- MODE ENUM (FOR SWITCHING) -----------
// defines which scan mode we're in
enum Mode {AZ, EL, BAZ};

Mode currentMode = AZ;



// ----------- PacketEntry STRUCTURE -----------

// Each PacketEntry runs at a specific time, with a specific encoded opcode, for a specific antenna, in a specific mode.
// tx, to_fro, and start_stop will not be strings because a string is 2 characters long
// we only need 1 character (remove the "" from the numbers).
typedef struct {
  unsigned long ms_time;
  char opcode[OPCODE];
  char data_word;
  char antenna_selection[ATENNA];
  char tx;
  char to_fro;
  char start_stop;
} PacketEntry;

// Define data in PROGMEM
///This will be generated by a python code
///Opcode will automatically be encoded
// sets the starting mode to azimuth

// Can't be const because I need to iterate the times. However,
// if the USSIM group can get a good frequency without scaling then you can make it a const.
const PacketEntry instructions[63] = {
	{0, "0000000000000000000000000", '0', "101", '0', '0', '0'},
	{47200, "0000000000000100110101101", '0', "000", '1', '0', '0'},
	{48800, "0000000000000000000000000", '0', "101", '1', '0', '0'},
	{48864, "0000000000000000000000000", '0', "101", '1', '0', '0'},
	{49248, "0000000000000000000000000", '0', "010", '1', '0', '0'},
	{49376, "0000000000000000000000000", '0', "001", '1', '0', '0'},
	{49504, "0000000000000000000000000", '0', "011", '1', '0', '0'},
	{49632, "0000000000000000000000000", '0', "100", '1', '0', '0'},
	{49760, "0000000000000000000000000", '0', "100", '1', '1', '1'},
	{55960, "0000000000000000000000000", '0', "100", '0', '1', '0'},
	{56260, "0000000000000000000000000", '0', "100", '0', '1', '0'},
	{56560, "0000000000000000000000000", '0', "100", '1', '0', '1'},
	{62760, "0000000000000000000000000", '0', "100", '1', '0', '0'},
	{62888, "0000000000000000000000000", '0', "101", '1', '0', '0'},
	{63100, "0000000000000000000000000", '0', "101", '0', '0', '0'},
	{209200, "0000000000000100110101101", '0', "000", '1', '0', '0'},
	{210800, "0000000000000000000000000", '0', "101", '1', '0', '0'},
	{210864, "0000000000000000000000000", '0', "101", '1', '0', '0'},
	{211248, "0000000000000000000000000", '0', "010", '1', '0', '0'},
	{211376, "0000000000000000000000000", '0', "001", '1', '0', '0'},
	{211504, "0000000000000000000000000", '0', "011", '1', '0', '0'},
	{211632, "0000000000000000000000000", '0', "100", '1', '0', '0'},
	{211760, "0000000000000000000000000", '0', "100", '1', '1', '1'},
	{217960, "0000000000000000000000000", '0', "100", '0', '1', '0'},
	{218260, "0000000000000000000000000", '0', "100", '0', '1', '0'},
	{218560, "0000000000000000000000000", '0', "100", '1', '0', '1'},
	{224760, "0000000000000000000000000", '0', "100", '1', '0', '0'},
	{224888, "0000000000000000000000000", '0', "101", '1', '0', '0'},
	{225100, "0000000000000000000000000", '0', "101", '0', '0', '0'},
	{260600, "0000000000000000000000000", '4', "000", '1', '0', '0'},
	{263700, "0000000000000000000000000", '0', "101", '0', '0', '0'},
	{285200, "0000000000000000000000000", '5', "000", '1', '0', '0'},
	{288300, "0000000000000000000000000", '0', "101", '0', '0', '0'},
	{378200, "0000000000000100110101101", '0', "000", '1', '0', '0'},
	{379800, "0000000000000000000000000", '0', "101", '1', '0', '0'},
	{379864, "0000000000000000000000000", '0', "101", '1', '0', '0'},
	{380248, "0000000000000000000000000", '0', "010", '1', '0', '0'},
	{380376, "0000000000000000000000000", '0', "001", '1', '0', '0'},
	{380504, "0000000000000000000000000", '0', "011", '1', '0', '0'},
	{380632, "0000000000000000000000000", '0', "100", '1', '0', '0'},
	{380760, "0000000000000000000000000", '0', "100", '1', '1', '1'},
	{386960, "0000000000000000000000000", '0', "100", '0', '1', '0'},
	{387260, "0000000000000000000000000", '0', "100", '0', '1', '0'},
	{387560, "0000000000000000000000000", '0', "100", '1', '0', '1'},
	{393760, "0000000000000000000000000", '0', "100", '1', '0', '0'},
	{393888, "0000000000000000000000000", '0', "101", '1', '0', '0'},
	{394100, "0000000000000000000000000", '0', "101", '0', '0', '0'},
	{430600, "0000000000000000000000000", '6', "000", '1', '0', '0'},
	{433700, "0000000000000000000000000", '0', "101", '0', '0', '0'},
	{552200, "0000000000000100110101101", '0', "000", '1', '0', '0'},
	{553800, "0000000000000000000000000", '0', "101", '1', '0', '0'},
	{553864, "0000000000000000000000000", '0', "101", '1', '0', '0'},
	{554248, "0000000000000000000000000", '0', "010", '1', '0', '0'},
	{554376, "0000000000000000000000000", '0', "001", '1', '0', '0'},
	{554504, "0000000000000000000000000", '0', "011", '1', '0', '0'},
	{554632, "0000000000000000000000000", '0', "100", '1', '0', '0'},
	{554760, "0000000000000000000000000", '0', "100", '1', '1', '1'},
	{560960, "0000000000000000000000000", '0', "100", '0', '1', '0'},
	{561260, "0000000000000000000000000", '0', "100", '0', '1', '0'},
	{561560, "0000000000000000000000000", '0', "100", '1', '0', '1'},
	{567760, "0000000000000000000000000", '0', "100", '1', '0', '0'},
	{567888, "0000000000000000000000000", '0', "101", '1', '0', '0'},
	{568100, "0000000000000000000000000", '0', "101", '0', '0', '0'}
};
// ----------- Global Variables ----------- 

// Time for everything to get set up. 
unsigned long startup_time = 0;

// Current time within 615 milliseconds and after 
unsigned long machineTime = 0;

// Used to increment through instructions array.
int curr_instruct = 0;

// Size of array
int size = sizeof(instructions) / sizeof(instructions[0]);

// each full scan cycle is 615 milliseconds
const unsigned long MAX_TIME = instructions[size - 1].ms_time + 500;

// ----------- DATA WORDS -----------

// BDW1â€“6 and ADWA1 values taken from Appendix A (Not decoded yet).
const char BDW[DATA_WORDS][BASIC] = {
  "000000000000010011111110010000000001100010011",
	"000000000000010011110001000111101000010000001",
	"000000000000010011011100010000010000000110000",
	"000000000000010011010011000110011110110011101",
	"000000000000010011001101011110111101000100010",
	"000000000000010011100101110001010100010111011"
};

const char ADW[AUX] = "00000000000001001100010110011111011101110000101100100010011110101100111001110010101011101";


// AZ mode can send AZ, BDW1, BDW2, BDW3, BDW4, BDW5, BDW6, ADWA1 and sync signal.
// EL mode can send EL and accept sync signal.
// BAZ can send BDW1, BDW2, BDW4, BDW6, and accept a sync signal.

void setup() {
  // start serial communication for debugging / command input
  //Serial.begin(9600);
  
  // setup pins
  pinMode(antennaPin1, OUTPUT);
  pinMode(antennaPin2, OUTPUT);
  pinMode(antennaPin3, OUTPUT);
  pinMode(phasePin, OUTPUT);
  pinMode(startPin, OUTPUT);
  pinMode(toPin, OUTPUT);
  pinMode(onPin, OUTPUT);
	pinMode(syncPin, OUTPUT);
	digitalWrite(syncPin, LOW);

  // startup message
  //Serial.println("UTCU Simulation Started");
  
  // Time it takes to set up everything at the very beginning.
  startup_time = micros();
}

void loop() {
    // loop through all instructions
    while(true) {
      // Gets current time. MAX_TIME will be scaled by scale factor (SCALE_FACTOR is decided by USSIM group to meet their requirements).
      machineTime = ((micros() - startup_time) % (MAX_TIME * SCALE_FACTOR)) / SCALE_FACTOR;

			// Start the sync at the beginning.
			if (machineTime == SYNC_START){
				digitalWrite(syncPin, HIGH);
			}
			else if (machineTime == SYNC_END){
				digitalWrite(syncPin, LOW);
			}


      // No need to modulus for actual test because we are only going to 615 once.
      // Can change if you want won't really affect code.
      // machineTime = micros() - startup_time; 
      
      // If time current time matches one in instruction.
      if (instructions[curr_instruct].ms_time == machineTime) {
        // Need to subtract '0' because sending a the character 1 send 49 (ascii number).
        digitalWrite(antennaPin1, instructions[curr_instruct].antenna_selection[0] - '0');
        digitalWrite(antennaPin2, instructions[curr_instruct].antenna_selection[1] - '0');
        digitalWrite(antennaPin3, instructions[curr_instruct].antenna_selection[2] - '0');
        digitalWrite(onPin, instructions[curr_instruct].tx - '0');
        digitalWrite(startPin, instructions[curr_instruct].start_stop - '0');
        digitalWrite(toPin, instructions[curr_instruct].to_fro - '0');
        //Check if a data word is being sent.
        if (instructions[curr_instruct].data_word == '0' && (strcmp(instructions[curr_instruct].opcode, NO_FUNCID) != 0)) {
          sendPhase(phasePin, instructions[curr_instruct].opcode, OPCODE);
					//sendWord(BDW[instructions[curr_instruct].data_word - '1']);
          //Serial.println("sending opcode");  // Testing purposes
        }
        else if (instructions[curr_instruct].data_word != '0'){
					//sendPhase(phasePin, instructions[curr_instruct].opcode, OPCODE);
					if (instructions[curr_instruct].data_word != '7'){
        		sendPhase(phasePin, BDW[instructions[curr_instruct].data_word - '1'], BASIC);
					}
					else {
						sendPhase(phasePin, ADW, AUX);
					}
        }
        curr_instruct = (curr_instruct+1) % size; // This is used for looping through the data (for testing).    
      }
    }
  }

// Outputs phase data.
void sendPhase(const int pin, const char data[], const int charSize){
  for (int i = 0; i < charSize - 1; i++){
    // If data byte is 1.
    if (data[i] == '1'){
      digitalWrite(pin, HIGH);
    }
    // If data byte is 0
    else{
      digitalWrite(pin, LOW);
    }
		delayMicroseconds(DELAY * SCALE_FACTOR);
  }
	digitalWrite(pin, LOW);
}
